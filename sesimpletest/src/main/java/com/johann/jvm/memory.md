### 内存模型

JVM运行时数据区由：程序计数器[Program Counter Register]，虚拟机栈[VM Stack]，本地方法栈[Native Method Stack]，堆[Heap]，方法区[Method Area]组成。

JVM内存结构由：程序计数器，堆，栈，本地方法栈，方法区组成。

见图：[jvm_memory.png]

#### 1 程序计数器

【线程私有的】，几乎不占用内存，用于取下一条执行命令。

它是一块较小的内存空间，可以看做是指向当前线程所执行的字节码的行号指示器。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程回复等基础功能都需要依赖计数器来完成。

##### 1） 为什么程序计数器为线程私有？

多线程切换线程时，保证线程在切换回能恢复到正常的执行位置继续执行，因此每条线程都需要一个独立的线程计数器，各线程之间计数器互不干扰，独立存储，为线程私有的内存。

##### 2） 程序计数器的值

如果线程正在执行的是一个java方法，那么程序计数器记录的是正在执行的虚拟机字节码指令的地址。
如果正在执行的是一个native方法，那么此时程序计数器记录的值为空[Undefined]。

【此内存区域是，唯一一个在java虚拟机规范中，没有规定任何OutOfMemoryError情况的区域。】


#### 2 堆

java堆是java虚拟机管理的内存中最大的一块，java堆是被【所有线程共享的一块内存区域】，堆的唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配内存。

java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们磁盘空间一样。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常
    
所有通过 new 创建的对象的内存都在堆中分配，其大小可以通过 -Xmx 和 -Xms 来调节。

堆被划分为新生代和老年代，新生代又被进一步划分为Eden（伊甸园）和Survivor（幸存者）区，最后Survivor由FromSpace和ToSpace组成。见图[young_old_permanent_generation]

##### 1）新生代

新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例。

对新生代的对象的垃圾收集成为 minor GC

##### 2）旧生代

用于存放新生代中经过多次垃圾回收仍然存活的对象。

对旧生代的对象的垃圾收集成为 full GC

#### 3 虚拟机栈

JAVA虚拟机栈，【也是线程私有的】，它的生命周期与线程保持一致，它存储的是当前线程运行方法时所需要的数据，指令，返回地址。

每个方法执行时，虚拟机栈都会创建一个栈帧（Stack Frame），用于存储：局部变量表、操作数栈、动态链接、方法出口等信息。

其中，局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double），
对象引用(reference类型，它不等同与对象本身，可能是一个指向对象真实地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置) ，
和returnAddress类型（指向了一条字节码指令的地址）。

局部变量表的存储空间是32位，刚好可以放一个int类型，所以长度为64为的long和double类型的数据会占用2个局部变量空间（Slot），【局部变量表的大小在编译器就已经确定了】。

在java虚拟机规范中，对java虚拟机栈规定了以下两种异常

##### 1）如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出 StackOverflowError 异常；

##### 2）如果虚拟机栈可以动态扩展（当前大部分虚拟机都可以动态扩展，只不过java虚拟机规范中也允许固定长度的虚拟机栈），扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常


#### 4 本地方法栈

【线程私有的】，用于支持native方法的执行，存储了每个native方法调用的状态。（String中的intern就是一个native方法）

本地方法栈和虚拟机栈所发挥的作用非常相似，区别就是：java虚拟机栈为虚拟机执行java方法（也就是字节码）服务；本地方法栈为虚拟机使用到的Native方法服务。

#### 5 方法区      

 方法区和堆一样，是各个【线程共享的区域】，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等       

JVM用永久代 [PermanetGeneration] 来存放方法区,（在JDK的HotSpot虚拟机中，可以认为方法区就是永久代，但是在其他类型的虚拟机中，没有永久代的概念）

32 位机器默认的永久代的大小为 64M，64 位的机器则为 85M。

可通过 -XX:PermSize 和 -XX:MaxPermSize 来指定最小值和最大值。


### 虚拟机中的堆和栈

#### 堆与栈

简单的来说，栈是运行时的单位，堆是存储的单位。

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

#### 为什么区分？

1）第一，从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。

2）第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。
一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。

3） 第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。
而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。
当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。

#### 堆，栈分别存的什么？

堆中存的是对象。栈中存的是基本数据类型（数据）和堆中对象的引用。

#### 为什么不把基本类型放堆中？

因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了。

#### java中是值传递还是引用传递？

值传递，只有值传递。

1）参数是基本类型

方法中传入的参数是基本类型，经过方法对参数处理后，原来的变量值不变。

其实，传入方法内的参数，只是原来变量的一份Copy，即在栈内再次开辟一个空间，用于存储这个传入的参数。在方法内改变参数的值，当然不会影响本体的值。

示例参见 [BasicParamTransTest] 

2）参数是引用类型

方法中传入的是引用类型，这个引用类型的数据是存储在堆内的，在栈内只是存储的这个对象的引用。所以在方法内传入的参数，其实只是这个引用的Copy，这两个引用指向同一个对象。
当我们在方法内改变这个参数的时候，实际上改变的是堆中的对象，所以原来的栈内引用没有改变，但是这个引用指向的对象，却改变了。

当对象是 String，或者基本数据类型的包装类时，参数传入方法处理后，原来的变量值不变。这是因为，【String 是不可变的，包装类的值也是不可变的】。
在方法中当参数被修改的时候，是在堆中重新开辟空间，存储新的字符串或包装类对象，并将参数重新指向新开辟空间的地址。参数是什么，原变量的Copy吖，原变量当然不变。

示例参见 [WrapperParamTransTest]  ， [StringTransTest]  ，  [ObjectParamTransTest]




### 永久代(PermGen) 去哪了？

在 Java 虚拟机（以下简称 JVM）中，类包含其对应的元数据，比如类的层级信息，
方法数据和方法信息（如字节码，栈和变量大小），运行时常量池，已确定的符号引用和虚方法表。

在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。
另外由于类作为 JVM 实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。

#### 为什么永久代被取代？

在java8及其以后，永久代不复存在，但这并不意味着类的元数据信息也消失了。这些数据被移到一个与堆不相干的本地区域，这个区域就是元空间。

对永久代进行调优比较困难，永久代中的元数据可能会随着每一次 Full GC 发生而进行移动，并且为永久代设置空间大小也是很难确定的，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等。

同时，HotSpot 虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化 Full GC 以及对以后的并发隔离类元数据等方面进行优化。

#### 永久代移除后的影响

由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，我们就不会遇到永久代存在时的内存溢出错误，
也不会出现泄漏的数据移到交换区这样的事情。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM 会自动根据类的元数据大小动态增加元空间的容量。

注意：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。

#### 元空间内存管理

元空间的内存管理由元空间虚拟机来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的 C++ 代码即可完成。

在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。

准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。
当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作，但是元空间内的元数据会进行扫描来确定 Java 引用。

#### 元空间调优

正如上面提到的，元空间虚拟机控制元空间的增长。但是有些时候我们想限制其增长，比如通过显式在命令行中设置 -XX:MaxMetaspaceSize。
默认情况下，-XX:MaxMetaspaceSize 的值没有限制，因此元空间甚至可以延伸到交换区，但是这时候当我们进行本地内存分配时将会失败。

对于一个 64 位的服务器端 JVM 来说，其默认的–XX:MetaspaceSize 值为 21MB，这就是初始的高水位线。
一旦触及到这个水位线，Full GC 将会被触发并卸载没有用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。

新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，这个高水位线则上升；如果释放空间过多，则高水位线下降。如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。
通过垃圾回收器的日志我们可以观察到 Full GC 多次调用。为了避免频繁的 GC，建议将–XX:MetaspaceSize 设置为一个相对较高的值。

经过多次 GC 之后，元空间虚拟机自动调节高水位线，以此来推迟下一次垃圾回收到来。

有这样两个选项 ‑XX:MinMetaspaceFreeRatio 和‑XX:MaxMetaspaceFreeRatio，他们类似于 GC 的 FreeRatio 选项，用来设置元空间空闲比例的最大值和最小值。我们可以通过命令行对这两个选项设置对应的值。


### jvm垃圾回收

GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器。
由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停

#### 分类

1）对新生代的对象的垃圾收集成为 minor GC；

2）对旧生代的对象的垃圾收集成为 full GC；

3）程序中主动调用System.gc()强制执行的GC为Full GC。

不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：

1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）；

2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）；

3）弱引用：在GC时一定会被GC回收；

4）虚引用：虚引用只是用来得知对象是否被GC。

四种引用参见 [JavaReference] 

### jvm 1.6 / 1.7 / 1.8 变化

1，1.8 以后，元数据区取代了永久代，元数据区和永久代类似，都是对JVM规范中方法区的实现。它俩的区别在于，元数据区使用的是本地内存，并不在虚拟机中。




### 参考
[1，JVM内存管理、JVM垃圾回收机制、新生代、老年代以及永久代 ---cnBlog](https://www.cnblogs.com/alsf/p/9017447.html)

[2，JVM内存模型详解(1.7与1.8的区别) ---CSDN](https://blog.csdn.net/qq_42651904/article/details/88862994)

[3，Java 永久代去哪儿了 ---InfoQ](https://www.infoq.cn/article/Java-PERMGEN-Removed/?itm_source=infoq_en&itm_medium=link_on_en_item&itm_campaign=item_in_other_langs)

[4，JVM调优总结（一）-- 一些概念 ---itepe](https://www.iteye.com/blog/pengjiaheng-518623)